{"ast":null,"code":"import { ORIGINAL } from './shared/constants.js';\nimport state$1 from './shared/state.js';\nimport { replaceObject, whileMuted, getSize, isTarget, updateDeep, clone, getValue, setValue } from './shared/utils.js';\nimport { get, extend, addProp } from './shared/paths.js';\nimport { onUpdateInNextStore } from './shared/pubSub.js';\nimport { createShallow } from './proxyManager.js';\nimport { flushUpdates, notifyByPath } from './updateManager.js';\n/**\r\n * This is the store, as exported to the user. When the store is passed to a\r\n * component, it is shallow cloned. This leaves us free to mutate the root\r\n * level directly.\r\n */\n\nstate$1.store = createShallow({});\n/**\r\n * Deep update the store, the following rules are followed:\r\n * - If updating the root level, the store object itself is mutated.\r\n * - For any other (deep) update we clone each node along the path to\r\n *   the target to update (the target is cloned too).\r\n */\n\nconst updateStore = ({\n  target,\n  prop,\n  value,\n  notifyTarget = false,\n  updater\n}) => whileMuted(() => {\n  let result; // This function doesn't know anything about the prop being set.\n  // It just finds the target (the parent of the prop) and\n  // calls updater() with it.\n\n  const targetPath = get(target); // Note that if this update is a method (e.g. arr.push()) then prop can be\n  // undefined, meaning the prop path won't be extended, and will just be\n  // the path of the target (the array) which is correct.\n\n  const propPath = extend(target, prop); // If we change the length/size of an array/map/set, we will want to\n  // trigger a render of the parent path.\n\n  let targetChangedSize = false;\n  const initialSize = getSize(target);\n  let newValue = value; // Make sure the new value is deeply wrapped in proxies, if it's a target\n\n  if (isTarget(newValue)) {\n    newValue = updateDeep(value, (item, thisPropPath) => {\n      if (!isTarget(item)) return item;\n      const next = clone(item);\n      addProp(next, [...propPath, ...thisPropPath]);\n      return createShallow(next);\n    });\n  }\n\n  if (!targetPath.length) {\n    // If the target is the store root, it's mutated in place.\n    result = updater(state$1.store, newValue);\n    targetChangedSize = getSize(state$1.store) !== initialSize;\n  } else {\n    targetPath.reduce((item, thisProp, i) => {\n      const thisValue = getValue(item, thisProp); // Shallow clone this level\n\n      let clone$1 = clone(thisValue);\n      addProp(clone$1, get(thisValue)); // Wrap the clone in a proxy\n\n      clone$1 = createShallow(clone$1); // Mutate this level (swap out the original for the clone)\n\n      setValue(item, thisProp, clone$1); // If we're at the end of the path, then 'clone' is our target\n\n      if (i === targetPath.length - 1) {\n        result = updater(clone$1, newValue);\n        targetChangedSize = getSize(clone$1) !== initialSize; // We keep a reference between the original target and the clone\n        // `target` may or may not be wrapped in a proxy (Maps and Sets are)\n        // So we check/get the unproxied version\n\n        state$1.nextVersionMap.set(target[ORIGINAL] || target, clone$1);\n      }\n\n      return clone$1;\n    }, state$1.store);\n  } // If the 'size' of a target changes, it's reasonable to assume that\n  // users of the target are going to need to re-render, else use the prop\n\n\n  const notifyPath = notifyTarget || targetChangedSize ? targetPath : propPath;\n  notifyByPath(notifyPath);\n  return result;\n});\n\nonUpdateInNextStore(updateStore);\n/**\r\n * Executes the provided function, then updates appropriate components and calls\r\n * listeners registered with `afterChange()`. Guaranteed to only trigger one\r\n * update. The provided function must only contain synchronous code.\r\n */\n\nconst batch = cb => {\n  state$1.isBatchUpdating = true;\n  cb();\n  state$1.isBatchUpdating = false;\n  flushUpdates();\n};\n/**\r\n * Empty the Recollect store and replace it with new data.\r\n */\n\n\nconst initStore = data => {\n  batch(() => {\n    replaceObject(state$1.store, data);\n  });\n};\n\nexport { batch, initStore, updateStore };","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/store.js"],"names":["ORIGINAL","state$1","replaceObject","whileMuted","getSize","isTarget","updateDeep","clone","getValue","setValue","get","extend","addProp","onUpdateInNextStore","createShallow","flushUpdates","notifyByPath","store","updateStore","target","prop","value","notifyTarget","updater","result","targetPath","propPath","targetChangedSize","initialSize","newValue","item","thisPropPath","next","length","reduce","thisProp","i","thisValue","clone$1","nextVersionMap","set","notifyPath","batch","cb","isBatchUpdating","initStore","data"],"mappings":"AAAA,SAASA,QAAT,QAAyB,uBAAzB;AACA,OAAOC,OAAP,MAAoB,mBAApB;AACA,SAASC,aAAT,EAAwBC,UAAxB,EAAoCC,OAApC,EAA6CC,QAA7C,EAAuDC,UAAvD,EAAmEC,KAAnE,EAA0EC,QAA1E,EAAoFC,QAApF,QAAoG,mBAApG;AACA,SAASC,GAAT,EAAcC,MAAd,EAAsBC,OAAtB,QAAqC,mBAArC;AACA,SAASC,mBAAT,QAAoC,oBAApC;AACA,SAASC,aAAT,QAA8B,mBAA9B;AACA,SAASC,YAAT,EAAuBC,YAAvB,QAA2C,oBAA3C;AAEA;;;;;;AAKAf,OAAO,CAACgB,KAAR,GAAgBH,aAAa,CAAC,EAAD,CAA7B;AACA;;;;;;;AAMA,MAAMI,WAAW,GAAG,CAAC;AAAEC,EAAAA,MAAF;AAAUC,EAAAA,IAAV;AAAgBC,EAAAA,KAAhB;AAAuBC,EAAAA,YAAY,GAAG,KAAtC;AAA6CC,EAAAA;AAA7C,CAAD,KAA6DpB,UAAU,CAAC,MAAM;AAC9F,MAAIqB,MAAJ,CAD8F,CAE9F;AACA;AACA;;AACA,QAAMC,UAAU,GAAGf,GAAG,CAACS,MAAD,CAAtB,CAL8F,CAM9F;AACA;AACA;;AACA,QAAMO,QAAQ,GAAGf,MAAM,CAACQ,MAAD,EAASC,IAAT,CAAvB,CAT8F,CAU9F;AACA;;AACA,MAAIO,iBAAiB,GAAG,KAAxB;AACA,QAAMC,WAAW,GAAGxB,OAAO,CAACe,MAAD,CAA3B;AACA,MAAIU,QAAQ,GAAGR,KAAf,CAd8F,CAe9F;;AACA,MAAIhB,QAAQ,CAACwB,QAAD,CAAZ,EAAwB;AACpBA,IAAAA,QAAQ,GAAGvB,UAAU,CAACe,KAAD,EAAQ,CAACS,IAAD,EAAOC,YAAP,KAAwB;AACjD,UAAI,CAAC1B,QAAQ,CAACyB,IAAD,CAAb,EACI,OAAOA,IAAP;AACJ,YAAME,IAAI,GAAGzB,KAAK,CAACuB,IAAD,CAAlB;AACAlB,MAAAA,OAAO,CAACoB,IAAD,EAAO,CAAC,GAAGN,QAAJ,EAAc,GAAGK,YAAjB,CAAP,CAAP;AACA,aAAOjB,aAAa,CAACkB,IAAD,CAApB;AACH,KANoB,CAArB;AAOH;;AACD,MAAI,CAACP,UAAU,CAACQ,MAAhB,EAAwB;AACpB;AACAT,IAAAA,MAAM,GAAGD,OAAO,CAACtB,OAAO,CAACgB,KAAT,EAAgBY,QAAhB,CAAhB;AACAF,IAAAA,iBAAiB,GAAGvB,OAAO,CAACH,OAAO,CAACgB,KAAT,CAAP,KAA2BW,WAA/C;AACH,GAJD,MAKK;AACDH,IAAAA,UAAU,CAACS,MAAX,CAAkB,CAACJ,IAAD,EAAOK,QAAP,EAAiBC,CAAjB,KAAuB;AACrC,YAAMC,SAAS,GAAG7B,QAAQ,CAACsB,IAAD,EAAOK,QAAP,CAA1B,CADqC,CAErC;;AACA,UAAIG,OAAO,GAAG/B,KAAK,CAAC8B,SAAD,CAAnB;AACAzB,MAAAA,OAAO,CAAC0B,OAAD,EAAU5B,GAAG,CAAC2B,SAAD,CAAb,CAAP,CAJqC,CAKrC;;AACAC,MAAAA,OAAO,GAAGxB,aAAa,CAACwB,OAAD,CAAvB,CANqC,CAOrC;;AACA7B,MAAAA,QAAQ,CAACqB,IAAD,EAAOK,QAAP,EAAiBG,OAAjB,CAAR,CARqC,CASrC;;AACA,UAAIF,CAAC,KAAKX,UAAU,CAACQ,MAAX,GAAoB,CAA9B,EAAiC;AAC7BT,QAAAA,MAAM,GAAGD,OAAO,CAACe,OAAD,EAAUT,QAAV,CAAhB;AACAF,QAAAA,iBAAiB,GAAGvB,OAAO,CAACkC,OAAD,CAAP,KAAqBV,WAAzC,CAF6B,CAG7B;AACA;AACA;;AACA3B,QAAAA,OAAO,CAACsC,cAAR,CAAuBC,GAAvB,CAA2BrB,MAAM,CAACnB,QAAD,CAAN,IAAoBmB,MAA/C,EAAuDmB,OAAvD;AACH;;AACD,aAAOA,OAAP;AACH,KAnBD,EAmBGrC,OAAO,CAACgB,KAnBX;AAoBH,GAnD6F,CAoD9F;AACA;;;AACA,QAAMwB,UAAU,GAAGnB,YAAY,IAAIK,iBAAhB,GAAoCF,UAApC,GAAiDC,QAApE;AACAV,EAAAA,YAAY,CAACyB,UAAD,CAAZ;AACA,SAAOjB,MAAP;AACH,CAzD0F,CAA3F;;AA0DAX,mBAAmB,CAACK,WAAD,CAAnB;AACA;;;;;;AAKA,MAAMwB,KAAK,GAAIC,EAAD,IAAQ;AAClB1C,EAAAA,OAAO,CAAC2C,eAAR,GAA0B,IAA1B;AACAD,EAAAA,EAAE;AACF1C,EAAAA,OAAO,CAAC2C,eAAR,GAA0B,KAA1B;AACA7B,EAAAA,YAAY;AACf,CALD;AAMA;;;;;AAGA,MAAM8B,SAAS,GAAIC,IAAD,IAAU;AACxBJ,EAAAA,KAAK,CAAC,MAAM;AACRxC,IAAAA,aAAa,CAACD,OAAO,CAACgB,KAAT,EAAgB6B,IAAhB,CAAb;AACH,GAFI,CAAL;AAGH,CAJD;;AAMA,SAASJ,KAAT,EAAgBG,SAAhB,EAA2B3B,WAA3B","sourcesContent":["import { ORIGINAL } from './shared/constants.js';\nimport state$1 from './shared/state.js';\nimport { replaceObject, whileMuted, getSize, isTarget, updateDeep, clone, getValue, setValue } from './shared/utils.js';\nimport { get, extend, addProp } from './shared/paths.js';\nimport { onUpdateInNextStore } from './shared/pubSub.js';\nimport { createShallow } from './proxyManager.js';\nimport { flushUpdates, notifyByPath } from './updateManager.js';\n\n/**\r\n * This is the store, as exported to the user. When the store is passed to a\r\n * component, it is shallow cloned. This leaves us free to mutate the root\r\n * level directly.\r\n */\r\nstate$1.store = createShallow({});\r\n/**\r\n * Deep update the store, the following rules are followed:\r\n * - If updating the root level, the store object itself is mutated.\r\n * - For any other (deep) update we clone each node along the path to\r\n *   the target to update (the target is cloned too).\r\n */\r\nconst updateStore = ({ target, prop, value, notifyTarget = false, updater, }) => whileMuted(() => {\r\n    let result;\r\n    // This function doesn't know anything about the prop being set.\r\n    // It just finds the target (the parent of the prop) and\r\n    // calls updater() with it.\r\n    const targetPath = get(target);\r\n    // Note that if this update is a method (e.g. arr.push()) then prop can be\r\n    // undefined, meaning the prop path won't be extended, and will just be\r\n    // the path of the target (the array) which is correct.\r\n    const propPath = extend(target, prop);\r\n    // If we change the length/size of an array/map/set, we will want to\r\n    // trigger a render of the parent path.\r\n    let targetChangedSize = false;\r\n    const initialSize = getSize(target);\r\n    let newValue = value;\r\n    // Make sure the new value is deeply wrapped in proxies, if it's a target\r\n    if (isTarget(newValue)) {\r\n        newValue = updateDeep(value, (item, thisPropPath) => {\r\n            if (!isTarget(item))\r\n                return item;\r\n            const next = clone(item);\r\n            addProp(next, [...propPath, ...thisPropPath]);\r\n            return createShallow(next);\r\n        });\r\n    }\r\n    if (!targetPath.length) {\r\n        // If the target is the store root, it's mutated in place.\r\n        result = updater(state$1.store, newValue);\r\n        targetChangedSize = getSize(state$1.store) !== initialSize;\r\n    }\r\n    else {\r\n        targetPath.reduce((item, thisProp, i) => {\r\n            const thisValue = getValue(item, thisProp);\r\n            // Shallow clone this level\r\n            let clone$1 = clone(thisValue);\r\n            addProp(clone$1, get(thisValue));\r\n            // Wrap the clone in a proxy\r\n            clone$1 = createShallow(clone$1);\r\n            // Mutate this level (swap out the original for the clone)\r\n            setValue(item, thisProp, clone$1);\r\n            // If we're at the end of the path, then 'clone' is our target\r\n            if (i === targetPath.length - 1) {\r\n                result = updater(clone$1, newValue);\r\n                targetChangedSize = getSize(clone$1) !== initialSize;\r\n                // We keep a reference between the original target and the clone\r\n                // `target` may or may not be wrapped in a proxy (Maps and Sets are)\r\n                // So we check/get the unproxied version\r\n                state$1.nextVersionMap.set(target[ORIGINAL] || target, clone$1);\r\n            }\r\n            return clone$1;\r\n        }, state$1.store);\r\n    }\r\n    // If the 'size' of a target changes, it's reasonable to assume that\r\n    // users of the target are going to need to re-render, else use the prop\r\n    const notifyPath = notifyTarget || targetChangedSize ? targetPath : propPath;\r\n    notifyByPath(notifyPath);\r\n    return result;\r\n});\r\nonUpdateInNextStore(updateStore);\r\n/**\r\n * Executes the provided function, then updates appropriate components and calls\r\n * listeners registered with `afterChange()`. Guaranteed to only trigger one\r\n * update. The provided function must only contain synchronous code.\r\n */\r\nconst batch = (cb) => {\r\n    state$1.isBatchUpdating = true;\r\n    cb();\r\n    state$1.isBatchUpdating = false;\r\n    flushUpdates();\r\n};\r\n/**\r\n * Empty the Recollect store and replace it with new data.\r\n */\r\nconst initStore = (data) => {\r\n    batch(() => {\r\n        replaceObject(state$1.store, data);\r\n    });\r\n};\n\nexport { batch, initStore, updateStore };\n"]},"metadata":{},"sourceType":"module"}