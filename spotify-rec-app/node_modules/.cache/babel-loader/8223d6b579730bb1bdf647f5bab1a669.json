{"ast":null,"code":"import { PATH, PROP_PATH_SEP } from './constants.js';\nimport { isObject } from './utils.js'; // Joins an array that potentially contains symbols, which need an explicit\n// 'toString()'\n\nconst join = (arr, joiner) => arr.map(item => item.toString()).join(joiner);\n/**\r\n * Convert a target and a prop into a user-friendly string like store.tasks.1.done\r\n */\n\n\nconst makeUserString = propPath => join(propPath, '.');\n\nconst makeInternalString = propPath => join(propPath, PROP_PATH_SEP);\n/**\r\n * Convert an internal string like `one~~~two~~~three` into a user-facing string\r\n * like `one.two.three`\r\n */\n\n\nconst internalToUser = internalPath => makeUserString(internalPath.split(PROP_PATH_SEP));\n/**\r\n * Takes the path stored in an object, and a new prop, and returns the two\r\n * combined\r\n */\n\n\nconst extend = (target, prop) => {\n  const basePath = target[PATH] || [];\n  if (typeof prop === 'undefined') return basePath;\n  return basePath.concat(prop);\n};\n/**\r\n * Convert a target and a prop into a user-friendly string like store.tasks.1.done\r\n */\n\n\nconst extendToUserString = (target, prop) => makeUserString(extend(target, prop));\n\nconst addProp = (target, propPath) => {\n  if (!target) return;\n  Object.defineProperty(target, PATH, {\n    value: propPath,\n    writable: true\n  });\n};\n\nconst get = target => target[PATH] || [];\n\nconst has = target => isObject(target) && PATH in target;\n\nexport { addProp, extend, extendToUserString, get, has, internalToUser, makeInternalString, makeUserString };","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/shared/paths.js"],"names":["PATH","PROP_PATH_SEP","isObject","join","arr","joiner","map","item","toString","makeUserString","propPath","makeInternalString","internalToUser","internalPath","split","extend","target","prop","basePath","concat","extendToUserString","addProp","Object","defineProperty","value","writable","get","has"],"mappings":"AAAA,SAASA,IAAT,EAAeC,aAAf,QAAoC,gBAApC;AACA,SAASC,QAAT,QAAyB,YAAzB,C,CAEA;AACA;;AACA,MAAMC,IAAI,GAAG,CAACC,GAAD,EAAMC,MAAN,KAAiBD,GAAG,CAACE,GAAJ,CAASC,IAAD,IAAUA,IAAI,CAACC,QAAL,EAAlB,EAAmCL,IAAnC,CAAwCE,MAAxC,CAA9B;AACA;;;;;AAGA,MAAMI,cAAc,GAAIC,QAAD,IAAcP,IAAI,CAACO,QAAD,EAAW,GAAX,CAAzC;;AACA,MAAMC,kBAAkB,GAAID,QAAD,IAAcP,IAAI,CAACO,QAAD,EAAWT,aAAX,CAA7C;AACA;;;;;;AAIA,MAAMW,cAAc,GAAIC,YAAD,IAAkBJ,cAAc,CAACI,YAAY,CAACC,KAAb,CAAmBb,aAAnB,CAAD,CAAvD;AACA;;;;;;AAIA,MAAMc,MAAM,GAAG,CAACC,MAAD,EAASC,IAAT,KAAkB;AAC7B,QAAMC,QAAQ,GAAGF,MAAM,CAAChB,IAAD,CAAN,IAAgB,EAAjC;AACA,MAAI,OAAOiB,IAAP,KAAgB,WAApB,EACI,OAAOC,QAAP;AACJ,SAAOA,QAAQ,CAACC,MAAT,CAAgBF,IAAhB,CAAP;AACH,CALD;AAMA;;;;;AAGA,MAAMG,kBAAkB,GAAG,CAACJ,MAAD,EAASC,IAAT,KAAkBR,cAAc,CAACM,MAAM,CAACC,MAAD,EAASC,IAAT,CAAP,CAA3D;;AACA,MAAMI,OAAO,GAAG,CAACL,MAAD,EAASN,QAAT,KAAsB;AAClC,MAAI,CAACM,MAAL,EACI;AACJM,EAAAA,MAAM,CAACC,cAAP,CAAsBP,MAAtB,EAA8BhB,IAA9B,EAAoC;AAChCwB,IAAAA,KAAK,EAAEd,QADyB;AAEhCe,IAAAA,QAAQ,EAAE;AAFsB,GAApC;AAIH,CAPD;;AAQA,MAAMC,GAAG,GAAIV,MAAD,IAAYA,MAAM,CAAChB,IAAD,CAAN,IAAgB,EAAxC;;AACA,MAAM2B,GAAG,GAAIX,MAAD,IAAYd,QAAQ,CAACc,MAAD,CAAR,IAAoBhB,IAAI,IAAIgB,MAApD;;AAEA,SAASK,OAAT,EAAkBN,MAAlB,EAA0BK,kBAA1B,EAA8CM,GAA9C,EAAmDC,GAAnD,EAAwDf,cAAxD,EAAwED,kBAAxE,EAA4FF,cAA5F","sourcesContent":["import { PATH, PROP_PATH_SEP } from './constants.js';\nimport { isObject } from './utils.js';\n\n// Joins an array that potentially contains symbols, which need an explicit\r\n// 'toString()'\r\nconst join = (arr, joiner) => arr.map((item) => item.toString()).join(joiner);\r\n/**\r\n * Convert a target and a prop into a user-friendly string like store.tasks.1.done\r\n */\r\nconst makeUserString = (propPath) => join(propPath, '.');\r\nconst makeInternalString = (propPath) => join(propPath, PROP_PATH_SEP);\r\n/**\r\n * Convert an internal string like `one~~~two~~~three` into a user-facing string\r\n * like `one.two.three`\r\n */\r\nconst internalToUser = (internalPath) => makeUserString(internalPath.split(PROP_PATH_SEP));\r\n/**\r\n * Takes the path stored in an object, and a new prop, and returns the two\r\n * combined\r\n */\r\nconst extend = (target, prop) => {\r\n    const basePath = target[PATH] || [];\r\n    if (typeof prop === 'undefined')\r\n        return basePath;\r\n    return basePath.concat(prop);\r\n};\r\n/**\r\n * Convert a target and a prop into a user-friendly string like store.tasks.1.done\r\n */\r\nconst extendToUserString = (target, prop) => makeUserString(extend(target, prop));\r\nconst addProp = (target, propPath) => {\r\n    if (!target)\r\n        return;\r\n    Object.defineProperty(target, PATH, {\r\n        value: propPath,\r\n        writable: true,\r\n    });\r\n};\r\nconst get = (target) => target[PATH] || [];\r\nconst has = (target) => isObject(target) && PATH in target;\n\nexport { addProp, extend, extendToUserString, get, has, internalToUser, makeInternalString, makeUserString };\n"]},"metadata":{},"sourceType":"module"}