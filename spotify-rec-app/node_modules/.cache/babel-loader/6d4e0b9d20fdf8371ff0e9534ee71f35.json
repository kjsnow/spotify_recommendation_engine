{"ast":null,"code":"import state$1 from './shared/state.js';\nimport { whileMuted } from './shared/utils.js';\nimport { has } from './shared/paths.js';\nimport { debug as debug$1 } from './shared/debug.js';\nimport { createShallow } from './proxyManager.js';\nimport { removeListenersForComponent } from './updateManager.js';\nimport React$1 from 'react';\nimport hoistNonReactStatics$1 from 'hoist-non-react-statics'; // As we render down into a tree of collected components, we will start/stop\n// recording\n\nconst componentStack = [];\n\nconst startRecordingGetsForComponent = component => {\n  if (!state$1.isInBrowser) return;\n  debug$1(() => {\n    console.groupCollapsed(`RENDER: <${component._name}>`);\n  });\n  state$1.currentComponent = component;\n  componentStack.push(state$1.currentComponent);\n};\n\nconst stopRecordingGetsForComponent = () => {\n  if (!state$1.isInBrowser) return;\n  debug$1(() => {\n    console.groupEnd();\n  });\n  componentStack.pop();\n  state$1.currentComponent = componentStack[componentStack.length - 1] || null;\n};\n/**\r\n * This shallow clones the store to pass as state to the collected\r\n * component.\r\n */\n\n\nconst getStoreClone = () => whileMuted(() => {\n  // We'll shallow clone the store so React knows it's new\n  const shallowClone = Object.assign({}, state$1.store); // ... but redirect all reads to the real store\n\n  state$1.nextVersionMap.set(shallowClone, state$1.store);\n  return createShallow(shallowClone);\n});\n\nconst collect = ComponentToWrap => {\n  const componentName = ComponentToWrap.displayName || ComponentToWrap.name || 'NamelessComponent';\n\n  class WrappedComponent extends React$1.PureComponent {\n    constructor() {\n      super(...arguments);\n      this.state = {\n        // This might be called by React when a parent component has updated with a new store,\n        // we want this component (if it's a child) to have that next store as well.\n        store: getStoreClone()\n      }; // TODO (davidg) 2020-02-28: use private #isMounted, waiting on\n      //  https://github.com/prettier/prettier/issues/7263\n\n      this._isMounted = false;\n      this._isMounting = true; // <React.StrictMode> will trigger multiple renders,\n      // we must disregard these\n\n      this._isRendering = false;\n      this._name = componentName;\n    }\n\n    componentDidMount() {\n      this._isMounted = true;\n      this._isMounting = false; // A user shouldn't pass data from the store into a collected component.\n      // See the issue linked in the error for details.\n\n      {\n        if (this.props) {\n          const recollectStoreProps = []; // Note this is only a shallow check.\n\n          Object.entries(this.props).forEach(([propName, propValue]) => {\n            // If this prop has a 'path', we know it's from the Recollect store\n            // This is not good!\n            if (has(propValue)) recollectStoreProps.push(propName);\n          }); // We'll just report the first match to keep the message simple\n\n          if (recollectStoreProps.length) {\n            console.error(`You are passing part of the Recollect store from one collected component to another, which can cause unpredictable behaviour.\\n Either remove the collect() wrapper from <${this._name}/>, or remove the \"${recollectStoreProps[0]}\" prop.\\n More info: https://git.io/JvMOj`);\n          }\n        }\n      } // Stop recording. For first render()\n\n      stopRecordingGetsForComponent();\n      this._isRendering = false;\n    }\n\n    componentDidUpdate() {\n      // Stop recording. For not-first render()\n      stopRecordingGetsForComponent();\n      this._isRendering = false;\n    }\n\n    componentWillUnmount() {\n      removeListenersForComponent(this);\n      this._isMounted = false;\n    }\n\n    update() {\n      // 1. If the component has already unmounted, don't try and set the state\n      // 2. The component might not have mounted YET, but is in the middle of its first\n      //    render cycle.\n      //    For example, if a user sets store.loading to true in App.componentDidMount\n      if (this._isMounted || this._isMounting) {\n        this.setState({\n          store: getStoreClone()\n        });\n      }\n    }\n\n    render() {\n      if (!this._isRendering) {\n        startRecordingGetsForComponent(this);\n        this._isRendering = true;\n      }\n\n      const props = Object.assign(Object.assign({}, this.props), {\n        store: this.state.store\n      });\n      return React$1.createElement(ComponentToWrap, Object.assign({}, props));\n    }\n\n  }\n\n  WrappedComponent.displayName = `Collected(${componentName})`; // @ts-ignore - I can't work this out\n\n  return hoistNonReactStatics$1(WrappedComponent, ComponentToWrap);\n};\n\nexport default collect;","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/collect.js"],"names":["state$1","whileMuted","has","debug","debug$1","createShallow","removeListenersForComponent","React$1","hoistNonReactStatics$1","componentStack","startRecordingGetsForComponent","component","isInBrowser","console","groupCollapsed","_name","currentComponent","push","stopRecordingGetsForComponent","groupEnd","pop","length","getStoreClone","shallowClone","Object","assign","store","nextVersionMap","set","collect","ComponentToWrap","componentName","displayName","name","WrappedComponent","PureComponent","constructor","arguments","state","_isMounted","_isMounting","_isRendering","componentDidMount","props","recollectStoreProps","entries","forEach","propName","propValue","error","componentDidUpdate","componentWillUnmount","update","setState","render","createElement"],"mappings":"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","sourcesContent":["import state$1 from './shared/state.js';\nimport { whileMuted } from './shared/utils.js';\nimport { has } from './shared/paths.js';\nimport { debug as debug$1 } from './shared/debug.js';\nimport { createShallow } from './proxyManager.js';\nimport { removeListenersForComponent } from './updateManager.js';\nimport React$1 from 'react';\nimport hoistNonReactStatics$1 from 'hoist-non-react-statics';\n\n// As we render down into a tree of collected components, we will start/stop\r\n// recording\r\nconst componentStack = [];\r\nconst startRecordingGetsForComponent = (component) => {\r\n    if (!state$1.isInBrowser)\r\n        return;\r\n    debug$1(() => {\r\n        console.groupCollapsed(`RENDER: <${component._name}>`);\r\n    });\r\n    state$1.currentComponent = component;\r\n    componentStack.push(state$1.currentComponent);\r\n};\r\nconst stopRecordingGetsForComponent = () => {\r\n    if (!state$1.isInBrowser)\r\n        return;\r\n    debug$1(() => {\r\n        console.groupEnd();\r\n    });\r\n    componentStack.pop();\r\n    state$1.currentComponent = componentStack[componentStack.length - 1] || null;\r\n};\r\n/**\r\n * This shallow clones the store to pass as state to the collected\r\n * component.\r\n */\r\nconst getStoreClone = () => whileMuted(() => {\r\n    // We'll shallow clone the store so React knows it's new\r\n    const shallowClone = Object.assign({}, state$1.store);\r\n    // ... but redirect all reads to the real store\r\n    state$1.nextVersionMap.set(shallowClone, state$1.store);\r\n    return createShallow(shallowClone);\r\n});\r\nconst collect = (ComponentToWrap) => {\r\n    const componentName = ComponentToWrap.displayName || ComponentToWrap.name || 'NamelessComponent';\r\n    class WrappedComponent extends React$1.PureComponent {\r\n        constructor() {\r\n            super(...arguments);\r\n            this.state = {\r\n                // This might be called by React when a parent component has updated with a new store,\r\n                // we want this component (if it's a child) to have that next store as well.\r\n                store: getStoreClone(),\r\n            };\r\n            // TODO (davidg) 2020-02-28: use private #isMounted, waiting on\r\n            //  https://github.com/prettier/prettier/issues/7263\r\n            this._isMounted = false;\r\n            this._isMounting = true;\r\n            // <React.StrictMode> will trigger multiple renders,\r\n            // we must disregard these\r\n            this._isRendering = false;\r\n            this._name = componentName;\r\n        }\r\n        componentDidMount() {\r\n            this._isMounted = true;\r\n            this._isMounting = false;\r\n            // A user shouldn't pass data from the store into a collected component.\r\n            // See the issue linked in the error for details.\r\n            {\r\n                if (this.props) {\r\n                    const recollectStoreProps = [];\r\n                    // Note this is only a shallow check.\r\n                    Object.entries(this.props).forEach(([propName, propValue]) => {\r\n                        // If this prop has a 'path', we know it's from the Recollect store\r\n                        // This is not good!\r\n                        if (has(propValue))\r\n                            recollectStoreProps.push(propName);\r\n                    });\r\n                    // We'll just report the first match to keep the message simple\r\n                    if (recollectStoreProps.length) {\r\n                        console.error(`You are passing part of the Recollect store from one collected component to another, which can cause unpredictable behaviour.\\n Either remove the collect() wrapper from <${this._name}/>, or remove the \"${recollectStoreProps[0]}\" prop.\\n More info: https://git.io/JvMOj`);\r\n                    }\r\n                }\r\n            }\r\n            // Stop recording. For first render()\r\n            stopRecordingGetsForComponent();\r\n            this._isRendering = false;\r\n        }\r\n        componentDidUpdate() {\r\n            // Stop recording. For not-first render()\r\n            stopRecordingGetsForComponent();\r\n            this._isRendering = false;\r\n        }\r\n        componentWillUnmount() {\r\n            removeListenersForComponent(this);\r\n            this._isMounted = false;\r\n        }\r\n        update() {\r\n            // 1. If the component has already unmounted, don't try and set the state\r\n            // 2. The component might not have mounted YET, but is in the middle of its first\r\n            //    render cycle.\r\n            //    For example, if a user sets store.loading to true in App.componentDidMount\r\n            if (this._isMounted || this._isMounting) {\r\n                this.setState({ store: getStoreClone() });\r\n            }\r\n        }\r\n        render() {\r\n            if (!this._isRendering) {\r\n                startRecordingGetsForComponent(this);\r\n                this._isRendering = true;\r\n            }\r\n            const props = Object.assign(Object.assign({}, this.props), { store: this.state.store });\r\n            return React$1.createElement(ComponentToWrap, Object.assign({}, props));\r\n        }\r\n    }\r\n    WrappedComponent.displayName = `Collected(${componentName})`;\r\n    // @ts-ignore - I can't work this out\r\n    return hoistNonReactStatics$1(WrappedComponent, ComponentToWrap);\r\n};\n\nexport default collect;\n"]},"metadata":{},"sourceType":"module"}