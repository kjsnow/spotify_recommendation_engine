{"ast":null,"code":"import { ORIGINAL } from './shared/constants.js';\nimport state$1 from './shared/state.js';\nimport { isMap, isSet, isFunction, isInternal, isArrayMutation, isArray, updateDeep, isTarget } from './shared/utils.js';\nimport { extend, get, makeInternalString, addProp } from './shared/paths.js';\nimport { logGet, logDelete, logSet } from './shared/debug.js';\nimport { dispatchUpdateInNextStore } from './shared/pubSub.js';\n/**\r\n * Add a new listener to be notified when a particular value in the store changes\r\n * To be used when a component reads from a property.\r\n */\n\nconst addListener = propPath => {\n  if (!state$1.currentComponent) return; // We use a string instead of an array because it's much easier to match\n\n  const pathString = makeInternalString(propPath);\n  const components = state$1.listeners.get(pathString) || new Set();\n  components.add(state$1.currentComponent);\n  state$1.listeners.set(pathString, components);\n};\n/**\r\n * These are the proxy handlers. Notes:\r\n * * We have different handlers (different traps) for object/array and\r\n *    map/set.\r\n * * When the proxy is muted, use Reflect[trap] and bypass any logic. The\r\n *    exception is Map/Set methods, where we must bind `this` first\r\n * * `ORIGINAL` lets us unwrap a proxied object\r\n * * We redirect to the 'next version' of a target if it has been changed\r\n */\n\n\nconst getHandlerForObject = targetObject => {\n  if (isMap(targetObject) || isSet(targetObject)) {\n    // Map() and Set() get a special handler, because reads and writes all\n    // happen in the get() trap (different to the get() method of the map/set!)\n    return {\n      get(target, prop) {\n        if (prop === ORIGINAL) return target;\n        let result = Reflect.get(target, prop); // The innards of Map and Set require this binding\n\n        if (isFunction(result)) result = result.bind(target); // Bail early for some things. Unlike objects/arrays, we will\n        // continue on even if !state.currentComponent\n\n        if (state$1.proxyIsMuted || isInternal(prop)) {\n          return result;\n        }\n\n        if (!state$1.currentComponent && state$1.redirectToNext) {\n          const nextVersion = state$1.nextVersionMap.get(target);\n          if (nextVersion) return Reflect.get(nextVersion, prop);\n        } // Adding to a Map\n\n\n        if (prop === \"set\"\n        /* Set */\n        ) {\n            const handler = {\n              apply(func, applyTarget, [key, value]) {\n                if (applyTarget.get(key) === value) return true; // No change, no need to carry on\n\n                return dispatchUpdateInNextStore({\n                  target: applyTarget,\n                  prop: key,\n                  value,\n                  updater: (finalTarget, newProxiedValue) => {\n                    logSet(target, prop, newProxiedValue); // We call the map.set() now, but on the item in the\n                    // store, and with the new args\n\n                    return Reflect.apply(finalTarget[prop], finalTarget, [key, newProxiedValue]);\n                  }\n                });\n              }\n\n            };\n            return new Proxy(result, handler);\n          } // Adding to a Set\n\n\n        if (prop === \"add\"\n        /* Add */\n        ) {\n            const handler = {\n              apply(func, applyTarget, [value]) {\n                if (applyTarget.has(value)) return true; // Would be a no op\n\n                return dispatchUpdateInNextStore({\n                  target: applyTarget,\n                  notifyTarget: true,\n                  value,\n                  updater: (finalTarget, newProxiedValue) => {\n                    logSet(target, prop, newProxiedValue);\n                    return Reflect.apply(finalTarget[prop], finalTarget, [newProxiedValue]);\n                  }\n                });\n              }\n\n            };\n            return new Proxy(result, handler);\n          } // On either a Set or Map\n\n\n        if (prop === \"clear\"\n        /* Clear */\n        || prop === \"delete\"\n        /* Delete */\n        ) {\n            const handler = {\n              apply(func, applyTarget, [key]) {\n                if (!applyTarget.size || prop === \"delete\"\n                /* Delete */\n                && !applyTarget.has(key)) {\n                  return false; // false indicates no change\n                }\n\n                return dispatchUpdateInNextStore({\n                  target: applyTarget,\n                  notifyTarget: true,\n                  updater: finalTarget => {\n                    logSet(target, prop);\n                    return Reflect.apply(finalTarget[prop], finalTarget, [key]);\n                  }\n                });\n              }\n\n            };\n            return new Proxy(result, handler);\n          } // Now that we've handled any modifying methods, we can\n        // just return the result if we're not in the render cycle.\n\n\n        if (!state$1.currentComponent) return result; // If we're reading a particular value, we'll want a listener for that\n        // We don't listen on `.has` because any change that would result in\n        // `.has` returning a different value would update the target\n\n        if (isMap(target) && prop === \"get\"\n        /* Get */\n        ) {\n            const handler = {\n              apply(func, applyTarget, args) {\n                addListener(extend(target, args[0]));\n                return Reflect.apply(func, applyTarget, args);\n              }\n\n            };\n            return new Proxy(result, handler);\n          } // For all other read operations, just return\n\n\n        return result;\n      }\n\n    };\n  }\n\n  return {\n    get(target, prop) {\n      // This allows getting the un-proxied version of a proxied object\n      if (prop === ORIGINAL) return target;\n      const result = Reflect.get(target, prop);\n      if (state$1.proxyIsMuted || isInternal(prop)) return result; // Mutating array methods make a lot of noise, so we wrap them in a proxy\n      // Only one update will be fired - for the actual array.\n\n      if (isArrayMutation(target, prop)) {\n        const handler = {\n          apply(func, applyTarget, args) {\n            return dispatchUpdateInNextStore({\n              target: applyTarget,\n              notifyTarget: true,\n              value: args,\n              updater: (finalTarget, proxiedArgs) => {\n                logSet(target, prop, proxiedArgs);\n                const updateResult = Reflect.apply( // @ts-ignore - Yes, symbol CAN be used as an index type\n                finalTarget[prop], finalTarget, proxiedArgs);\n                const rootPath = get(target); // At this point, the array is updated. But the paths of the\n                // items could be wrong, so we refresh them.\n\n                updateDeep(finalTarget, (item, path) => {\n                  if (isTarget(item)) {\n                    addProp(item, [...rootPath, ...path]);\n                  }\n                });\n                return updateResult;\n              }\n            });\n          }\n\n        };\n        return new Proxy(result, handler);\n      } // For all other methods (.join, .toString(), etc) return the function\n      // @ts-ignore - wrong, symbol can be used an an index type\n\n\n      if (isFunction(target[prop])) return result;\n\n      if (state$1.currentComponent) {\n        // We record a get if a component is rendering, with the exception\n        // of reading array length. This would be redundant, since changes to\n        // length trigger a change on the array itself\n        if (!(isArray(target) && prop === \"length\"\n        /* Length */\n        )) {\n          logGet(target, prop, result);\n          addListener(extend(target, prop));\n        }\n      } else if (state$1.redirectToNext) {\n        // When we're outside the render cycle, we route\n        // requests to the 'next version'\n        // Note, this will result in another get(), but on the equivalent\n        // target from the next store. muteProxy will be set so this line\n        // isn't triggered in an infinite loop\n        const nextVersion = state$1.nextVersionMap.get(target);\n        if (nextVersion) return Reflect.get(nextVersion, prop);\n      }\n\n      return result;\n    },\n\n    has(target, prop) {\n      const result = Reflect.has(target, prop);\n      if (state$1.proxyIsMuted || isInternal(prop)) return result;\n\n      if (state$1.currentComponent) {\n        // Arrays use `has` too, but we capture a listener elsewhere for that.\n        // Here we only want to capture access to objects\n        if (!isArray(target)) {\n          logGet(target, prop);\n          addListener(extend(target, prop));\n        }\n      } else {\n        const nextVersion = state$1.nextVersionMap.get(target);\n        if (nextVersion) return Reflect.has(nextVersion, prop);\n      }\n\n      return result;\n    },\n\n    ownKeys(target) {\n      const result = Reflect.ownKeys(target);\n      if (state$1.proxyIsMuted) return result;\n\n      if (state$1.currentComponent) {\n        logGet(target);\n        addListener(get(target));\n      } else {\n        const nextVersion = state$1.nextVersionMap.get(target);\n        if (nextVersion) return Reflect.ownKeys(nextVersion);\n      }\n\n      return result;\n    },\n\n    set(target, prop, value) {\n      if (state$1.proxyIsMuted) return Reflect.set(target, prop, value);\n      {\n        if (state$1.currentComponent) {\n          console.error([`You are attempting to modify the store during a render cycle. `, `(You're setting \"${prop.toString()}\" to \"${value}\" somewhere)\\n`, `This could result in subtle bugs. `, `If you're changing the store in componentDidMount, wrap your `, `code in a setTimeout() to allow the render cycle to complete `, `before changing the store.`].join(''));\n        }\n      } // If there's no change, we return\n      // @ts-ignore - target[prop] is fine\n\n      if (target[prop] === value) return true;\n      return dispatchUpdateInNextStore({\n        target,\n        prop,\n        value,\n        updater: (finalTarget, newValueProxy) => {\n          logSet(target, prop, newValueProxy);\n          return Reflect.set(finalTarget, prop, newValueProxy);\n        }\n      });\n    },\n\n    deleteProperty(target, prop) {\n      if (state$1.proxyIsMuted) return Reflect.deleteProperty(target, prop);\n      return dispatchUpdateInNextStore({\n        target,\n        prop,\n        notifyTarget: true,\n        updater: finalTarget => {\n          logDelete(target, prop);\n          return Reflect.deleteProperty(finalTarget, prop);\n        }\n      });\n    }\n\n  };\n};\n/**\r\n * Wrap an item in a proxy\r\n */\n\n\nconst createShallow = target => {\n  {\n    if (!target) throw Error('There is no target');\n  }\n  return new Proxy(target, getHandlerForObject(target));\n};\n\nexport { createShallow, getHandlerForObject };","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/proxyManager.js"],"names":["ORIGINAL","state$1","isMap","isSet","isFunction","isInternal","isArrayMutation","isArray","updateDeep","isTarget","extend","get","makeInternalString","addProp","logGet","logDelete","logSet","dispatchUpdateInNextStore","addListener","propPath","currentComponent","pathString","components","listeners","Set","add","set","getHandlerForObject","targetObject","target","prop","result","Reflect","bind","proxyIsMuted","redirectToNext","nextVersion","nextVersionMap","handler","apply","func","applyTarget","key","value","updater","finalTarget","newProxiedValue","Proxy","has","notifyTarget","size","args","proxiedArgs","updateResult","rootPath","item","path","ownKeys","console","error","toString","join","newValueProxy","deleteProperty","createShallow","Error"],"mappings":"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","sourcesContent":["import { ORIGINAL } from './shared/constants.js';\nimport state$1 from './shared/state.js';\nimport { isMap, isSet, isFunction, isInternal, isArrayMutation, isArray, updateDeep, isTarget } from './shared/utils.js';\nimport { extend, get, makeInternalString, addProp } from './shared/paths.js';\nimport { logGet, logDelete, logSet } from './shared/debug.js';\nimport { dispatchUpdateInNextStore } from './shared/pubSub.js';\n\n/**\r\n * Add a new listener to be notified when a particular value in the store changes\r\n * To be used when a component reads from a property.\r\n */\r\nconst addListener = (propPath) => {\r\n    if (!state$1.currentComponent)\r\n        return;\r\n    // We use a string instead of an array because it's much easier to match\r\n    const pathString = makeInternalString(propPath);\r\n    const components = state$1.listeners.get(pathString) || new Set();\r\n    components.add(state$1.currentComponent);\r\n    state$1.listeners.set(pathString, components);\r\n};\r\n/**\r\n * These are the proxy handlers. Notes:\r\n * * We have different handlers (different traps) for object/array and\r\n *    map/set.\r\n * * When the proxy is muted, use Reflect[trap] and bypass any logic. The\r\n *    exception is Map/Set methods, where we must bind `this` first\r\n * * `ORIGINAL` lets us unwrap a proxied object\r\n * * We redirect to the 'next version' of a target if it has been changed\r\n */\r\nconst getHandlerForObject = (targetObject) => {\r\n    if (isMap(targetObject) || isSet(targetObject)) {\r\n        // Map() and Set() get a special handler, because reads and writes all\r\n        // happen in the get() trap (different to the get() method of the map/set!)\r\n        return {\r\n            get(target, prop) {\r\n                if (prop === ORIGINAL)\r\n                    return target;\r\n                let result = Reflect.get(target, prop);\r\n                // The innards of Map and Set require this binding\r\n                if (isFunction(result))\r\n                    result = result.bind(target);\r\n                // Bail early for some things. Unlike objects/arrays, we will\r\n                // continue on even if !state.currentComponent\r\n                if (state$1.proxyIsMuted || isInternal(prop)) {\r\n                    return result;\r\n                }\r\n                if (!state$1.currentComponent && state$1.redirectToNext) {\r\n                    const nextVersion = state$1.nextVersionMap.get(target);\r\n                    if (nextVersion)\r\n                        return Reflect.get(nextVersion, prop);\r\n                }\r\n                // Adding to a Map\r\n                if (prop === \"set\" /* Set */) {\r\n                    const handler = {\r\n                        apply(func, applyTarget, [key, value]) {\r\n                            if (applyTarget.get(key) === value)\r\n                                return true; // No change, no need to carry on\r\n                            return dispatchUpdateInNextStore({\r\n                                target: applyTarget,\r\n                                prop: key,\r\n                                value,\r\n                                updater: (finalTarget, newProxiedValue) => {\r\n                                    logSet(target, prop, newProxiedValue);\r\n                                    // We call the map.set() now, but on the item in the\r\n                                    // store, and with the new args\r\n                                    return Reflect.apply(finalTarget[prop], finalTarget, [\r\n                                        key,\r\n                                        newProxiedValue,\r\n                                    ]);\r\n                                },\r\n                            });\r\n                        },\r\n                    };\r\n                    return new Proxy(result, handler);\r\n                }\r\n                // Adding to a Set\r\n                if (prop === \"add\" /* Add */) {\r\n                    const handler = {\r\n                        apply(func, applyTarget, [value]) {\r\n                            if (applyTarget.has(value))\r\n                                return true; // Would be a no op\r\n                            return dispatchUpdateInNextStore({\r\n                                target: applyTarget,\r\n                                notifyTarget: true,\r\n                                value,\r\n                                updater: (finalTarget, newProxiedValue) => {\r\n                                    logSet(target, prop, newProxiedValue);\r\n                                    return Reflect.apply(finalTarget[prop], finalTarget, [\r\n                                        newProxiedValue,\r\n                                    ]);\r\n                                },\r\n                            });\r\n                        },\r\n                    };\r\n                    return new Proxy(result, handler);\r\n                }\r\n                // On either a Set or Map\r\n                if (prop === \"clear\" /* Clear */ || prop === \"delete\" /* Delete */) {\r\n                    const handler = {\r\n                        apply(func, applyTarget, [key]) {\r\n                            if (!applyTarget.size ||\r\n                                (prop === \"delete\" /* Delete */ && !applyTarget.has(key))) {\r\n                                return false; // false indicates no change\r\n                            }\r\n                            return dispatchUpdateInNextStore({\r\n                                target: applyTarget,\r\n                                notifyTarget: true,\r\n                                updater: (finalTarget) => {\r\n                                    logSet(target, prop);\r\n                                    return Reflect.apply(finalTarget[prop], finalTarget, [key]);\r\n                                },\r\n                            });\r\n                        },\r\n                    };\r\n                    return new Proxy(result, handler);\r\n                }\r\n                // Now that we've handled any modifying methods, we can\r\n                // just return the result if we're not in the render cycle.\r\n                if (!state$1.currentComponent)\r\n                    return result;\r\n                // If we're reading a particular value, we'll want a listener for that\r\n                // We don't listen on `.has` because any change that would result in\r\n                // `.has` returning a different value would update the target\r\n                if (isMap(target) && prop === \"get\" /* Get */) {\r\n                    const handler = {\r\n                        apply(func, applyTarget, args) {\r\n                            addListener(extend(target, args[0]));\r\n                            return Reflect.apply(func, applyTarget, args);\r\n                        },\r\n                    };\r\n                    return new Proxy(result, handler);\r\n                }\r\n                // For all other read operations, just return\r\n                return result;\r\n            },\r\n        };\r\n    }\r\n    return {\r\n        get(target, prop) {\r\n            // This allows getting the un-proxied version of a proxied object\r\n            if (prop === ORIGINAL)\r\n                return target;\r\n            const result = Reflect.get(target, prop);\r\n            if (state$1.proxyIsMuted || isInternal(prop))\r\n                return result;\r\n            // Mutating array methods make a lot of noise, so we wrap them in a proxy\r\n            // Only one update will be fired - for the actual array.\r\n            if (isArrayMutation(target, prop)) {\r\n                const handler = {\r\n                    apply(func, applyTarget, args) {\r\n                        return dispatchUpdateInNextStore({\r\n                            target: applyTarget,\r\n                            notifyTarget: true,\r\n                            value: args,\r\n                            updater: (finalTarget, proxiedArgs) => {\r\n                                logSet(target, prop, proxiedArgs);\r\n                                const updateResult = Reflect.apply(\r\n                                // @ts-ignore - Yes, symbol CAN be used as an index type\r\n                                finalTarget[prop], finalTarget, proxiedArgs);\r\n                                const rootPath = get(target);\r\n                                // At this point, the array is updated. But the paths of the\r\n                                // items could be wrong, so we refresh them.\r\n                                updateDeep(finalTarget, (item, path) => {\r\n                                    if (isTarget(item)) {\r\n                                        addProp(item, [...rootPath, ...path]);\r\n                                    }\r\n                                });\r\n                                return updateResult;\r\n                            },\r\n                        });\r\n                    },\r\n                };\r\n                return new Proxy(result, handler);\r\n            }\r\n            // For all other methods (.join, .toString(), etc) return the function\r\n            // @ts-ignore - wrong, symbol can be used an an index type\r\n            if (isFunction(target[prop]))\r\n                return result;\r\n            if (state$1.currentComponent) {\r\n                // We record a get if a component is rendering, with the exception\r\n                // of reading array length. This would be redundant, since changes to\r\n                // length trigger a change on the array itself\r\n                if (!(isArray(target) && prop === \"length\" /* Length */)) {\r\n                    logGet(target, prop, result);\r\n                    addListener(extend(target, prop));\r\n                }\r\n            }\r\n            else if (state$1.redirectToNext) {\r\n                // When we're outside the render cycle, we route\r\n                // requests to the 'next version'\r\n                // Note, this will result in another get(), but on the equivalent\r\n                // target from the next store. muteProxy will be set so this line\r\n                // isn't triggered in an infinite loop\r\n                const nextVersion = state$1.nextVersionMap.get(target);\r\n                if (nextVersion)\r\n                    return Reflect.get(nextVersion, prop);\r\n            }\r\n            return result;\r\n        },\r\n        has(target, prop) {\r\n            const result = Reflect.has(target, prop);\r\n            if (state$1.proxyIsMuted || isInternal(prop))\r\n                return result;\r\n            if (state$1.currentComponent) {\r\n                // Arrays use `has` too, but we capture a listener elsewhere for that.\r\n                // Here we only want to capture access to objects\r\n                if (!isArray(target)) {\r\n                    logGet(target, prop);\r\n                    addListener(extend(target, prop));\r\n                }\r\n            }\r\n            else {\r\n                const nextVersion = state$1.nextVersionMap.get(target);\r\n                if (nextVersion)\r\n                    return Reflect.has(nextVersion, prop);\r\n            }\r\n            return result;\r\n        },\r\n        ownKeys(target) {\r\n            const result = Reflect.ownKeys(target);\r\n            if (state$1.proxyIsMuted)\r\n                return result;\r\n            if (state$1.currentComponent) {\r\n                logGet(target);\r\n                addListener(get(target));\r\n            }\r\n            else {\r\n                const nextVersion = state$1.nextVersionMap.get(target);\r\n                if (nextVersion)\r\n                    return Reflect.ownKeys(nextVersion);\r\n            }\r\n            return result;\r\n        },\r\n        set(target, prop, value) {\r\n            if (state$1.proxyIsMuted)\r\n                return Reflect.set(target, prop, value);\r\n            {\r\n                if (state$1.currentComponent) {\r\n                    console.error([\r\n                        `You are attempting to modify the store during a render cycle. `,\r\n                        `(You're setting \"${prop.toString()}\" to \"${value}\" somewhere)\\n`,\r\n                        `This could result in subtle bugs. `,\r\n                        `If you're changing the store in componentDidMount, wrap your `,\r\n                        `code in a setTimeout() to allow the render cycle to complete `,\r\n                        `before changing the store.`,\r\n                    ].join(''));\r\n                }\r\n            }\r\n            // If there's no change, we return\r\n            // @ts-ignore - target[prop] is fine\r\n            if (target[prop] === value)\r\n                return true;\r\n            return dispatchUpdateInNextStore({\r\n                target,\r\n                prop,\r\n                value,\r\n                updater: (finalTarget, newValueProxy) => {\r\n                    logSet(target, prop, newValueProxy);\r\n                    return Reflect.set(finalTarget, prop, newValueProxy);\r\n                },\r\n            });\r\n        },\r\n        deleteProperty(target, prop) {\r\n            if (state$1.proxyIsMuted)\r\n                return Reflect.deleteProperty(target, prop);\r\n            return dispatchUpdateInNextStore({\r\n                target,\r\n                prop,\r\n                notifyTarget: true,\r\n                updater: (finalTarget) => {\r\n                    logDelete(target, prop);\r\n                    return Reflect.deleteProperty(finalTarget, prop);\r\n                },\r\n            });\r\n        },\r\n    };\r\n};\r\n/**\r\n * Wrap an item in a proxy\r\n */\r\nconst createShallow = (target) => {\r\n    {\r\n        if (!target)\r\n            throw Error('There is no target');\r\n    }\r\n    return new Proxy(target, getHandlerForObject(target));\r\n};\n\nexport { createShallow, getHandlerForObject };\n"]},"metadata":{},"sourceType":"module"}