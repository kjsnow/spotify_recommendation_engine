{"ast":null,"code":"import { LS_KEYS } from './constants.js';\nimport state$1 from './state.js';\nimport { updateDeep, clone } from './utils.js';\nimport { get, set } from './ls.js';\nimport { afterChange } from './pubSub.js';\nimport { initStore } from '../store.js';\nconst timeTravelState = {\n  currentIndex: 0,\n  history: [],\n  historyLimit: 50,\n  muteHistory: false\n};\n\nconst pruneHistory = () => {\n  if (timeTravelState.history.length > timeTravelState.historyLimit) {\n    const removeCount = timeTravelState.history.length - timeTravelState.historyLimit;\n    timeTravelState.history.splice(0, removeCount);\n    timeTravelState.currentIndex = timeTravelState.history.length - 1;\n  }\n};\n/**\r\n * Pick the store instance at the defined index from history\r\n * and apply it as the current store\r\n */\n\n\nconst applyStoreAtIndex = () => {\n  const nextStore = timeTravelState.history[timeTravelState.currentIndex].store;\n  timeTravelState.muteHistory = true;\n  initStore(nextStore);\n  timeTravelState.muteHistory = false;\n  console.info(`Showing index ${timeTravelState.currentIndex} of ${timeTravelState.history.length - 1}`);\n};\n/**\r\n * Apply a limit to the number of history items to keep in memory\r\n */\n\n\nconst setHistoryLimit = num => {\n  if (typeof num === 'number') {\n    set(LS_KEYS.RR_HISTORY_LIMIT, num);\n    timeTravelState.historyLimit = num;\n    pruneHistory();\n\n    if (num === 0) {\n      console.info('Time travel is now turned off');\n    }\n  } else {\n    console.error(num, 'must be a number');\n  }\n};\n/**\r\n * Return this history array.\r\n * We return the data without the proxies for readability. We do this when\r\n * retrieving rather than when putting the store in history for performance.\r\n */\n\n\nconst getHistory = () => {\n  state$1.redirectToNext = false;\n  const cleanStore = updateDeep(timeTravelState.history, item => clone(item));\n  state$1.redirectToNext = true;\n  return cleanStore;\n};\n\nconst back = () => {\n  if (!timeTravelState.currentIndex) {\n    console.info('You are already at the beginning');\n  } else {\n    timeTravelState.currentIndex--;\n    applyStoreAtIndex();\n  }\n};\n\nconst forward = () => {\n  if (timeTravelState.currentIndex === timeTravelState.history.length - 1) {\n    console.info('You are already at the end');\n  } else {\n    timeTravelState.currentIndex++;\n    applyStoreAtIndex();\n  }\n};\n\nconst goTo = index => {\n  if (typeof index !== 'number' || index > timeTravelState.history.length - 1 || index < 0) {\n    console.warn(`${index} is not valid. Pick a number between 0 and ${timeTravelState.history.length - 1}.`);\n  } else {\n    timeTravelState.currentIndex = index;\n    applyStoreAtIndex();\n  }\n};\n/**\r\n * For resetting history between tests\r\n */\n\n\nconst clearHistory = () => {\n  timeTravelState.history.length = 0;\n  timeTravelState.currentIndex = 0;\n}; // We wrap this in a NODE_ENV check so rollup ignores it during build\n// (it doesn't work this out from the NODE_ENV check in index.ts)\n\n\n{\n  const storedHistoryLimit = get(LS_KEYS.RR_HISTORY_LIMIT);\n\n  if (storedHistoryLimit && typeof storedHistoryLimit === 'number') {\n    timeTravelState.historyLimit = storedHistoryLimit;\n  }\n\n  let pruneQueueTimeout; // NodeJs.Timer or number\n\n  timeTravelState.history.push({\n    store: Object.assign({}, state$1.store),\n    changedProps: ['INITIAL_STATE']\n  });\n  afterChange(e => {\n    // Setting historyLimit to 0 turns off time travel\n    if (!timeTravelState.muteHistory && timeTravelState.historyLimit !== 0) {\n      // If we're not looking at the most recent point in history, discard\n      // everything in the future\n      if (timeTravelState.history.length && // False the very first time this fires\n      timeTravelState.currentIndex !== timeTravelState.history.length - 1) {\n        timeTravelState.history.length = timeTravelState.currentIndex + 1;\n      } // We shallow clone because the store OBJECT gets mutated\n      // Don't need to deep clone since the store CONTENTS never mutate\n\n\n      timeTravelState.history.push({\n        store: Object.assign({}, e.store),\n        changedProps: e.changedProps\n      });\n      timeTravelState.currentIndex = timeTravelState.history.length - 1;\n      clearTimeout(pruneQueueTimeout);\n      pruneQueueTimeout = setTimeout(pruneHistory, 100);\n    }\n  });\n}\nexport { back, clearHistory, forward, getHistory, goTo, setHistoryLimit };","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/shared/timeTravel.js"],"names":["LS_KEYS","state$1","updateDeep","clone","get","set","afterChange","initStore","timeTravelState","currentIndex","history","historyLimit","muteHistory","pruneHistory","length","removeCount","splice","applyStoreAtIndex","nextStore","store","console","info","setHistoryLimit","num","RR_HISTORY_LIMIT","error","getHistory","redirectToNext","cleanStore","item","back","forward","goTo","index","warn","clearHistory","storedHistoryLimit","pruneQueueTimeout","push","Object","assign","changedProps","e","clearTimeout","setTimeout"],"mappings":"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","sourcesContent":["import { LS_KEYS } from './constants.js';\nimport state$1 from './state.js';\nimport { updateDeep, clone } from './utils.js';\nimport { get, set } from './ls.js';\nimport { afterChange } from './pubSub.js';\nimport { initStore } from '../store.js';\n\nconst timeTravelState = {\r\n    currentIndex: 0,\r\n    history: [],\r\n    historyLimit: 50,\r\n    muteHistory: false,\r\n};\r\nconst pruneHistory = () => {\r\n    if (timeTravelState.history.length > timeTravelState.historyLimit) {\r\n        const removeCount = timeTravelState.history.length - timeTravelState.historyLimit;\r\n        timeTravelState.history.splice(0, removeCount);\r\n        timeTravelState.currentIndex = timeTravelState.history.length - 1;\r\n    }\r\n};\r\n/**\r\n * Pick the store instance at the defined index from history\r\n * and apply it as the current store\r\n */\r\nconst applyStoreAtIndex = () => {\r\n    const nextStore = timeTravelState.history[timeTravelState.currentIndex].store;\r\n    timeTravelState.muteHistory = true;\r\n    initStore(nextStore);\r\n    timeTravelState.muteHistory = false;\r\n    console.info(`Showing index ${timeTravelState.currentIndex} of ${timeTravelState.history.length - 1}`);\r\n};\r\n/**\r\n * Apply a limit to the number of history items to keep in memory\r\n */\r\nconst setHistoryLimit = (num) => {\r\n    if (typeof num === 'number') {\r\n        set(LS_KEYS.RR_HISTORY_LIMIT, num);\r\n        timeTravelState.historyLimit = num;\r\n        pruneHistory();\r\n        if (num === 0) {\r\n            console.info('Time travel is now turned off');\r\n        }\r\n    }\r\n    else {\r\n        console.error(num, 'must be a number');\r\n    }\r\n};\r\n/**\r\n * Return this history array.\r\n * We return the data without the proxies for readability. We do this when\r\n * retrieving rather than when putting the store in history for performance.\r\n */\r\nconst getHistory = () => {\r\n    state$1.redirectToNext = false;\r\n    const cleanStore = updateDeep(timeTravelState.history, (item) => clone(item));\r\n    state$1.redirectToNext = true;\r\n    return cleanStore;\r\n};\r\nconst back = () => {\r\n    if (!timeTravelState.currentIndex) {\r\n        console.info('You are already at the beginning');\r\n    }\r\n    else {\r\n        timeTravelState.currentIndex--;\r\n        applyStoreAtIndex();\r\n    }\r\n};\r\nconst forward = () => {\r\n    if (timeTravelState.currentIndex === timeTravelState.history.length - 1) {\r\n        console.info('You are already at the end');\r\n    }\r\n    else {\r\n        timeTravelState.currentIndex++;\r\n        applyStoreAtIndex();\r\n    }\r\n};\r\nconst goTo = (index) => {\r\n    if (typeof index !== 'number' ||\r\n        index > timeTravelState.history.length - 1 ||\r\n        index < 0) {\r\n        console.warn(`${index} is not valid. Pick a number between 0 and ${timeTravelState.history.length - 1}.`);\r\n    }\r\n    else {\r\n        timeTravelState.currentIndex = index;\r\n        applyStoreAtIndex();\r\n    }\r\n};\r\n/**\r\n * For resetting history between tests\r\n */\r\nconst clearHistory = () => {\r\n    timeTravelState.history.length = 0;\r\n    timeTravelState.currentIndex = 0;\r\n};\r\n// We wrap this in a NODE_ENV check so rollup ignores it during build\r\n// (it doesn't work this out from the NODE_ENV check in index.ts)\r\n{\r\n    const storedHistoryLimit = get(LS_KEYS.RR_HISTORY_LIMIT);\r\n    if (storedHistoryLimit && typeof storedHistoryLimit === 'number') {\r\n        timeTravelState.historyLimit = storedHistoryLimit;\r\n    }\r\n    let pruneQueueTimeout; // NodeJs.Timer or number\r\n    timeTravelState.history.push({\r\n        store: Object.assign({}, state$1.store),\r\n        changedProps: ['INITIAL_STATE'],\r\n    });\r\n    afterChange((e) => {\r\n        // Setting historyLimit to 0 turns off time travel\r\n        if (!timeTravelState.muteHistory && timeTravelState.historyLimit !== 0) {\r\n            // If we're not looking at the most recent point in history, discard\r\n            // everything in the future\r\n            if (timeTravelState.history.length && // False the very first time this fires\r\n                timeTravelState.currentIndex !== timeTravelState.history.length - 1) {\r\n                timeTravelState.history.length = timeTravelState.currentIndex + 1;\r\n            }\r\n            // We shallow clone because the store OBJECT gets mutated\r\n            // Don't need to deep clone since the store CONTENTS never mutate\r\n            timeTravelState.history.push({\r\n                store: Object.assign({}, e.store),\r\n                changedProps: e.changedProps,\r\n            });\r\n            timeTravelState.currentIndex = timeTravelState.history.length - 1;\r\n            clearTimeout(pruneQueueTimeout);\r\n            pruneQueueTimeout = setTimeout(pruneHistory, 100);\r\n        }\r\n    });\r\n}\n\nexport { back, clearHistory, forward, getHistory, goTo, setHistoryLimit };\n"]},"metadata":{},"sourceType":"module"}