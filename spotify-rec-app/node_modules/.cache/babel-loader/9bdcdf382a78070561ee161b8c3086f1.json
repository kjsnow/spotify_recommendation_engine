{"ast":null,"code":"import { PATH } from './constants.js';\nimport state$1 from './state.js'; // 'object' meaning 'plain object'.\n\nconst isObject = item => !!item && typeof item === 'object' && item.constructor === Object;\n\nconst isArray = item => Array.isArray(item);\n\nconst isMap = item => item instanceof Map;\n\nconst isSet = item => item instanceof Set; // A target is one of the four types that Recollect will proxy\n\n\nconst isTarget = item => isObject(item) || isArray(item) || isMap(item) || isSet(item); // This is internal to JS or to Recollect\n\n\nconst isInternal = prop => prop === PATH || prop === 'constructor' || prop === 'toJSON' || // Various type-checking libraries call these\nprop === '@@toStringTag' || prop === Symbol.toStringTag;\n\nconst isFunction = item => typeof item === 'function';\n\nconst isArrayMutation = (target, prop) => isArray(target) && [\"copyWithin\"\n/* CopyWithin */\n, \"fill\"\n/* Fill */\n, \"pop\"\n/* Pop */\n, \"push\"\n/* Push */\n, \"reverse\"\n/* Reverse */\n, \"shift\"\n/* Shift */\n, \"sort\"\n/* Sort */\n, \"splice\"\n/* Splice */\n, \"unshift\"\n/* Unshift */\n].includes(prop);\n\nconst clone = target => {\n  if (isObject(target)) return Object.assign({}, target); // @ts-ignore\n\n  if (isArray(target)) return target.slice(); // @ts-ignore\n\n  if (isMap(target)) return new Map(target); // @ts-ignore\n\n  if (isSet(target)) return new Set(target);\n  return target;\n};\n/**\r\n * Get the value from an object. This is for end-user objects. E.g. not\r\n * accessing a symbol property on a Map object.\r\n */\n\n\nconst getValue = (target, prop) => {\n  if (isMap(target)) return target.get(prop);\n  if (isSet(target)) return prop;\n  if (isArray(target)) return target[prop];\n  return target[prop];\n};\n\nconst setValue = (mutableTarget, prop, value) => {\n  if (isObject(mutableTarget)) {\n    mutableTarget[prop] = value;\n  } else if (isArray(mutableTarget)) {\n    // @ts-ignore - is fine, prop can be a symbol\n    mutableTarget[prop] = value;\n  } else if (isMap(mutableTarget)) {\n    // @ts-ignore\n    mutableTarget.set(prop, value);\n  } else if (isSet(mutableTarget)) {\n    // @ts-ignore\n    mutableTarget.add(value);\n  } else {\n    throw Error('Unexpected type');\n  }\n};\n\nconst getSize = item => {\n  if (isObject(item)) return Object.keys(item).length; // @ts-ignore - TS thinks item is never\n\n  if (isArray(item)) return item.length; // @ts-ignore - TS thinks item is never\n\n  if (isMap(item) || isSet(item)) return item.size;\n  throw Error('Unexpected type');\n};\n/**\r\n * Shallow replaces the contents of one object with the contents of another.\r\n * The top level object will remain the same, but all changed content will\r\n * be replaced with the new content.\r\n */\n\n\nconst replaceObject = (mutableTarget, nextObject) => {\n  if (nextObject) {\n    // From the new data, add to the old data anything that's new\n    // (from the top level props only)\n    Object.entries(nextObject).forEach(([prop, value]) => {\n      if (mutableTarget[prop] !== value) {\n        mutableTarget[prop] = value;\n      }\n    }); // Clear out any keys that aren't in the new data\n\n    Object.keys(mutableTarget).forEach(prop => {\n      if (!(prop in nextObject)) {\n        delete mutableTarget[prop];\n      }\n    });\n  } else {\n    // Just empty the old object\n    Object.keys(mutableTarget).forEach(prop => {\n      delete mutableTarget[prop];\n    });\n  }\n};\n/**\r\n * Traverse a tree, calling a callback for each node with the item and the path.\r\n * This can either mutate each value, or return a new value to create a clone.\r\n * @example const clone = utils.updateDeep(original, utils.clone);\r\n * Only traverses the targets supported by Recollect.\r\n */\n\n\nconst updateDeep = (mutableTarget, updater) => {\n  const path = [];\n\n  const processLevel = target => {\n    const updated = updater(target, path.slice()); // If the updater returns something, use it. Else mutate the original.\n\n    const next = typeof updated !== 'undefined' ? updated : target;\n\n    const handleEntry = (prop, value) => {\n      path.push(prop);\n      const processed = processLevel(value);\n      path.pop();\n      setValue(next, prop, processed);\n    };\n\n    if (isObject(next)) {\n      Object.entries(next).forEach(([prop, value]) => {\n        handleEntry(prop, value);\n      });\n    } else if (isArray(next) || isMap(next)) {\n      next.forEach((value, prop) => {\n        handleEntry(prop, value);\n      });\n    } else if (isSet(next)) {\n      // A set is special - you can't reassign what's in a particular\n      // 'position' like the other three, so we do some fancy footwork...\n      const setContents = Array.from(next);\n      next.clear();\n      setContents.forEach(value => {\n        handleEntry(value, value);\n      });\n    }\n\n    return next;\n  };\n\n  return processLevel(mutableTarget);\n};\n/**\r\n * Does some work while the proxy is muted. Returns the result of the\r\n * callback as a convenience.\r\n * This prevents components from being subscribed to reads from the store,\r\n * it does not prevent updates being triggered.\r\n */\n\n\nconst whileMuted = cb => {\n  state$1.proxyIsMuted = true;\n  const result = cb();\n  state$1.proxyIsMuted = false;\n  return result;\n};\n/**\r\n * This is a convenience method that triggers a read on each item in the array.\r\n * When used during the render cycle of a collected component, it has the\r\n * side-effect of subscribing that component to each item in the array.\r\n */\n\n\nconst useProps = props => {\n  // useProps must never return, so it can be used in the body of a component\n  props.includes(0);\n};\n\nexport { clone, getSize, getValue, isArray, isArrayMutation, isFunction, isInternal, isMap, isObject, isSet, isTarget, replaceObject, setValue, updateDeep, useProps, whileMuted };","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/shared/utils.js"],"names":["PATH","state$1","isObject","item","constructor","Object","isArray","Array","isMap","Map","isSet","Set","isTarget","isInternal","prop","Symbol","toStringTag","isFunction","isArrayMutation","target","includes","clone","assign","slice","getValue","get","setValue","mutableTarget","value","set","add","Error","getSize","keys","length","size","replaceObject","nextObject","entries","forEach","updateDeep","updater","path","processLevel","updated","next","handleEntry","push","processed","pop","setContents","from","clear","whileMuted","cb","proxyIsMuted","result","useProps","props"],"mappings":"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","sourcesContent":["import { PATH } from './constants.js';\nimport state$1 from './state.js';\n\n// 'object' meaning 'plain object'.\r\nconst isObject = (item) => !!item && typeof item === 'object' && item.constructor === Object;\r\nconst isArray = (item) => Array.isArray(item);\r\nconst isMap = (item) => item instanceof Map;\r\nconst isSet = (item) => item instanceof Set;\r\n// A target is one of the four types that Recollect will proxy\r\nconst isTarget = (item) => isObject(item) || isArray(item) || isMap(item) || isSet(item);\r\n// This is internal to JS or to Recollect\r\nconst isInternal = (prop) => prop === PATH ||\r\n    prop === 'constructor' ||\r\n    prop === 'toJSON' ||\r\n    // Various type-checking libraries call these\r\n    prop === '@@toStringTag' ||\r\n    prop === Symbol.toStringTag;\r\nconst isFunction = (item) => typeof item === 'function';\r\nconst isArrayMutation = (target, prop) => isArray(target) &&\r\n    [\r\n        \"copyWithin\" /* CopyWithin */,\r\n        \"fill\" /* Fill */,\r\n        \"pop\" /* Pop */,\r\n        \"push\" /* Push */,\r\n        \"reverse\" /* Reverse */,\r\n        \"shift\" /* Shift */,\r\n        \"sort\" /* Sort */,\r\n        \"splice\" /* Splice */,\r\n        \"unshift\" /* Unshift */,\r\n    ].includes(prop);\r\nconst clone = (target) => {\r\n    if (isObject(target))\r\n        return Object.assign({}, target);\r\n    // @ts-ignore\r\n    if (isArray(target))\r\n        return target.slice();\r\n    // @ts-ignore\r\n    if (isMap(target))\r\n        return new Map(target);\r\n    // @ts-ignore\r\n    if (isSet(target))\r\n        return new Set(target);\r\n    return target;\r\n};\r\n/**\r\n * Get the value from an object. This is for end-user objects. E.g. not\r\n * accessing a symbol property on a Map object.\r\n */\r\nconst getValue = (target, prop) => {\r\n    if (isMap(target))\r\n        return target.get(prop);\r\n    if (isSet(target))\r\n        return prop;\r\n    if (isArray(target))\r\n        return target[prop];\r\n    return target[prop];\r\n};\r\nconst setValue = (mutableTarget, prop, value) => {\r\n    if (isObject(mutableTarget)) {\r\n        mutableTarget[prop] = value;\r\n    }\r\n    else if (isArray(mutableTarget)) {\r\n        // @ts-ignore - is fine, prop can be a symbol\r\n        mutableTarget[prop] = value;\r\n    }\r\n    else if (isMap(mutableTarget)) {\r\n        // @ts-ignore\r\n        mutableTarget.set(prop, value);\r\n    }\r\n    else if (isSet(mutableTarget)) {\r\n        // @ts-ignore\r\n        mutableTarget.add(value);\r\n    }\r\n    else {\r\n        throw Error('Unexpected type');\r\n    }\r\n};\r\nconst getSize = (item) => {\r\n    if (isObject(item))\r\n        return Object.keys(item).length;\r\n    // @ts-ignore - TS thinks item is never\r\n    if (isArray(item))\r\n        return item.length;\r\n    // @ts-ignore - TS thinks item is never\r\n    if (isMap(item) || isSet(item))\r\n        return item.size;\r\n    throw Error('Unexpected type');\r\n};\r\n/**\r\n * Shallow replaces the contents of one object with the contents of another.\r\n * The top level object will remain the same, but all changed content will\r\n * be replaced with the new content.\r\n */\r\nconst replaceObject = (mutableTarget, nextObject) => {\r\n    if (nextObject) {\r\n        // From the new data, add to the old data anything that's new\r\n        // (from the top level props only)\r\n        Object.entries(nextObject).forEach(([prop, value]) => {\r\n            if (mutableTarget[prop] !== value) {\r\n                mutableTarget[prop] = value;\r\n            }\r\n        });\r\n        // Clear out any keys that aren't in the new data\r\n        Object.keys(mutableTarget).forEach((prop) => {\r\n            if (!(prop in nextObject)) {\r\n                delete mutableTarget[prop];\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // Just empty the old object\r\n        Object.keys(mutableTarget).forEach((prop) => {\r\n            delete mutableTarget[prop];\r\n        });\r\n    }\r\n};\r\n/**\r\n * Traverse a tree, calling a callback for each node with the item and the path.\r\n * This can either mutate each value, or return a new value to create a clone.\r\n * @example const clone = utils.updateDeep(original, utils.clone);\r\n * Only traverses the targets supported by Recollect.\r\n */\r\nconst updateDeep = (mutableTarget, updater) => {\r\n    const path = [];\r\n    const processLevel = (target) => {\r\n        const updated = updater(target, path.slice());\r\n        // If the updater returns something, use it. Else mutate the original.\r\n        const next = typeof updated !== 'undefined' ? updated : target;\r\n        const handleEntry = (prop, value) => {\r\n            path.push(prop);\r\n            const processed = processLevel(value);\r\n            path.pop();\r\n            setValue(next, prop, processed);\r\n        };\r\n        if (isObject(next)) {\r\n            Object.entries(next).forEach(([prop, value]) => {\r\n                handleEntry(prop, value);\r\n            });\r\n        }\r\n        else if (isArray(next) || isMap(next)) {\r\n            next.forEach((value, prop) => {\r\n                handleEntry(prop, value);\r\n            });\r\n        }\r\n        else if (isSet(next)) {\r\n            // A set is special - you can't reassign what's in a particular\r\n            // 'position' like the other three, so we do some fancy footwork...\r\n            const setContents = Array.from(next);\r\n            next.clear();\r\n            setContents.forEach((value) => {\r\n                handleEntry(value, value);\r\n            });\r\n        }\r\n        return next;\r\n    };\r\n    return processLevel(mutableTarget);\r\n};\r\n/**\r\n * Does some work while the proxy is muted. Returns the result of the\r\n * callback as a convenience.\r\n * This prevents components from being subscribed to reads from the store,\r\n * it does not prevent updates being triggered.\r\n */\r\nconst whileMuted = (cb) => {\r\n    state$1.proxyIsMuted = true;\r\n    const result = cb();\r\n    state$1.proxyIsMuted = false;\r\n    return result;\r\n};\r\n/**\r\n * This is a convenience method that triggers a read on each item in the array.\r\n * When used during the render cycle of a collected component, it has the\r\n * side-effect of subscribing that component to each item in the array.\r\n */\r\nconst useProps = (props) => {\r\n    // useProps must never return, so it can be used in the body of a component\r\n    props.includes(0);\r\n};\n\nexport { clone, getSize, getValue, isArray, isArrayMutation, isFunction, isInternal, isMap, isObject, isSet, isTarget, replaceObject, setValue, updateDeep, useProps, whileMuted };\n"]},"metadata":{},"sourceType":"module"}