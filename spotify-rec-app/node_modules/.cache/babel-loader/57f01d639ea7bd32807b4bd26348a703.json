{"ast":null,"code":"import state$1 from './shared/state.js';\nimport { makeInternalString, makeUserString } from './shared/paths.js';\nimport { logUpdate } from './shared/debug.js';\nimport batchedUpdates$1 from './shared/batchedUpdates.js';\nconst queue = {\n  components: new Map(),\n  changedPaths: new Set()\n};\n\nconst flushUpdates = () => {\n  // We batch updates here so that React will collect all setState() calls\n  // (one for each component being updated) before triggering a render.\n  // In other words: MANY .update() calls, ONE render.\n  // This is subtly different to what the Recollect batch() function does -\n  // it ensures that the listeners are only notified once for\n  // multiple store changes\n  // In other words: MANY store updates, ONE call to flushUpdates()\n  batchedUpdates$1(() => {\n    queue.components.forEach((propsUpdated, component) => {\n      logUpdate(component, Array.from(propsUpdated));\n      component.update();\n    });\n  });\n  state$1.manualListeners.forEach(cb => cb({\n    changedProps: Array.from(queue.changedPaths),\n    renderedComponents: Array.from(queue.components.keys()),\n    store: state$1.store\n  }));\n  queue.components.clear();\n  queue.changedPaths.clear();\n};\n/**\r\n * Updates any component listening to:\r\n * - the exact propPath that has been changed. E.g. `tasks.2`\r\n * - a path further up the object tree. E.g. a component listening\r\n *   on `tasks.0` need to know if `tasks = 'foo'` happens\r\n * And if the path being notified is the top level (an empty path), everyone\r\n * gets updated.\r\n */\n\n\nconst notifyByPath = propPath => {\n  const pathString = makeInternalString(propPath);\n  const userFriendlyPropPath = makeUserString(propPath);\n  queue.changedPaths.add(userFriendlyPropPath);\n  state$1.listeners.forEach((components, listenerPath) => {\n    if (pathString === '' || // Notify everyone for top-level changes\n    pathString === listenerPath) {\n      components.forEach(component => {\n        const propsUpdated = queue.components.get(component) || new Set();\n        propsUpdated.add(userFriendlyPropPath);\n        queue.components.set(component, propsUpdated);\n      });\n    }\n  }); // If we're not batch updating, flush the changes now, otherwise this\n  // will be called when the batch is complete\n\n  if (!state$1.isBatchUpdating) flushUpdates();\n};\n\nconst removeListenersForComponent = componentToRemove => {\n  state$1.listeners.forEach((components, listenerPath) => {\n    const filteredComponents = Array.from(components).filter(existingComponent => existingComponent !== componentToRemove);\n\n    if (filteredComponents.length) {\n      state$1.listeners.set(listenerPath, new Set(filteredComponents));\n    } else {\n      // If there are no components left listening, remove the path\n      // For example, leaving a page will unmount a bunch of components\n      state$1.listeners.delete(listenerPath);\n    }\n  });\n};\n\nexport { flushUpdates, notifyByPath, removeListenersForComponent };","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/updateManager.js"],"names":["state$1","makeInternalString","makeUserString","logUpdate","batchedUpdates$1","queue","components","Map","changedPaths","Set","flushUpdates","forEach","propsUpdated","component","Array","from","update","manualListeners","cb","changedProps","renderedComponents","keys","store","clear","notifyByPath","propPath","pathString","userFriendlyPropPath","add","listeners","listenerPath","get","set","isBatchUpdating","removeListenersForComponent","componentToRemove","filteredComponents","filter","existingComponent","length","delete"],"mappings":"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","sourcesContent":["import state$1 from './shared/state.js';\nimport { makeInternalString, makeUserString } from './shared/paths.js';\nimport { logUpdate } from './shared/debug.js';\nimport batchedUpdates$1 from './shared/batchedUpdates.js';\n\nconst queue = {\r\n    components: new Map(),\r\n    changedPaths: new Set(),\r\n};\r\nconst flushUpdates = () => {\r\n    // We batch updates here so that React will collect all setState() calls\r\n    // (one for each component being updated) before triggering a render.\r\n    // In other words: MANY .update() calls, ONE render.\r\n    // This is subtly different to what the Recollect batch() function does -\r\n    // it ensures that the listeners are only notified once for\r\n    // multiple store changes\r\n    // In other words: MANY store updates, ONE call to flushUpdates()\r\n    batchedUpdates$1(() => {\r\n        queue.components.forEach((propsUpdated, component) => {\r\n            logUpdate(component, Array.from(propsUpdated));\r\n            component.update();\r\n        });\r\n    });\r\n    state$1.manualListeners.forEach((cb) => cb({\r\n        changedProps: Array.from(queue.changedPaths),\r\n        renderedComponents: Array.from(queue.components.keys()),\r\n        store: state$1.store,\r\n    }));\r\n    queue.components.clear();\r\n    queue.changedPaths.clear();\r\n};\r\n/**\r\n * Updates any component listening to:\r\n * - the exact propPath that has been changed. E.g. `tasks.2`\r\n * - a path further up the object tree. E.g. a component listening\r\n *   on `tasks.0` need to know if `tasks = 'foo'` happens\r\n * And if the path being notified is the top level (an empty path), everyone\r\n * gets updated.\r\n */\r\nconst notifyByPath = (propPath) => {\r\n    const pathString = makeInternalString(propPath);\r\n    const userFriendlyPropPath = makeUserString(propPath);\r\n    queue.changedPaths.add(userFriendlyPropPath);\r\n    state$1.listeners.forEach((components, listenerPath) => {\r\n        if (pathString === '' || // Notify everyone for top-level changes\r\n            pathString === listenerPath) {\r\n            components.forEach((component) => {\r\n                const propsUpdated = queue.components.get(component) || new Set();\r\n                propsUpdated.add(userFriendlyPropPath);\r\n                queue.components.set(component, propsUpdated);\r\n            });\r\n        }\r\n    });\r\n    // If we're not batch updating, flush the changes now, otherwise this\r\n    // will be called when the batch is complete\r\n    if (!state$1.isBatchUpdating)\r\n        flushUpdates();\r\n};\r\nconst removeListenersForComponent = (componentToRemove) => {\r\n    state$1.listeners.forEach((components, listenerPath) => {\r\n        const filteredComponents = Array.from(components).filter((existingComponent) => existingComponent !== componentToRemove);\r\n        if (filteredComponents.length) {\r\n            state$1.listeners.set(listenerPath, new Set(filteredComponents));\r\n        }\r\n        else {\r\n            // If there are no components left listening, remove the path\r\n            // For example, leaving a page will unmount a bunch of components\r\n            state$1.listeners.delete(listenerPath);\r\n        }\r\n    });\r\n};\n\nexport { flushUpdates, notifyByPath, removeListenersForComponent };\n"]},"metadata":{},"sourceType":"module"}