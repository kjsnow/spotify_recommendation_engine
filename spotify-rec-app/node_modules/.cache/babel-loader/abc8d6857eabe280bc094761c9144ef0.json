{"ast":null,"code":"import { whileMuted } from './utils.js';\nimport * as OriginalPropTypes$1 from 'prop-types';\nlet EnvPropTypes; // In the dev build of Recollect, we wrap PropTypes in a proxy so we can\n// mute the store while the prop types library reads the props.\n\n{\n  // The PropTypes object is made up of functions that call functions, so\n  // we recursively wrap responses in the same handler\n  const wrapMeIfYouCan = (item, handler) => {\n    if (typeof item === 'function' || typeof item === 'object' && item !== null) {\n      return new Proxy(item, handler);\n    }\n\n    return item;\n  };\n\n  const handler = {\n    get(...args) {\n      return wrapMeIfYouCan(Reflect.get(...args), this);\n    },\n\n    apply(...args) {\n      // Here we mute the function calls\n      const result = whileMuted(() => Reflect.apply(...args));\n      return wrapMeIfYouCan(result, this);\n    }\n\n  };\n  EnvPropTypes = new Proxy(OriginalPropTypes$1, handler);\n} // We do this so we're exporting a const (EnvPropTypes is a let)\n\nconst PropTypes = EnvPropTypes;\nexport default PropTypes;","map":{"version":3,"sources":["/Users/kyle.snow/node_modules/react-recollect/dist/esm/development/shared/propTypes.js"],"names":["whileMuted","OriginalPropTypes$1","EnvPropTypes","wrapMeIfYouCan","item","handler","Proxy","get","args","Reflect","apply","result","PropTypes"],"mappings":"AAAA,SAASA,UAAT,QAA2B,YAA3B;AACA,OAAO,KAAKC,mBAAZ,MAAqC,YAArC;AAEA,IAAIC,YAAJ,C,CACA;AACA;;AACA;AACI;AACA;AACA,QAAMC,cAAc,GAAG,CAACC,IAAD,EAAOC,OAAP,KAAmB;AACtC,QAAI,OAAOD,IAAP,KAAgB,UAAhB,IACC,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAD1C,EACiD;AAC7C,aAAO,IAAIE,KAAJ,CAAUF,IAAV,EAAgBC,OAAhB,CAAP;AACH;;AACD,WAAOD,IAAP;AACH,GAND;;AAOA,QAAMC,OAAO,GAAG;AACZE,IAAAA,GAAG,CAAC,GAAGC,IAAJ,EAAU;AACT,aAAOL,cAAc,CAACM,OAAO,CAACF,GAAR,CAAY,GAAGC,IAAf,CAAD,EAAuB,IAAvB,CAArB;AACH,KAHW;;AAIZE,IAAAA,KAAK,CAAC,GAAGF,IAAJ,EAAU;AACX;AACA,YAAMG,MAAM,GAAGX,UAAU,CAAC,MAAMS,OAAO,CAACC,KAAR,CAAc,GAAGF,IAAjB,CAAP,CAAzB;AACA,aAAOL,cAAc,CAACQ,MAAD,EAAS,IAAT,CAArB;AACH;;AARW,GAAhB;AAUAT,EAAAA,YAAY,GAAG,IAAII,KAAJ,CAAUL,mBAAV,EAA+BI,OAA/B,CAAf;AACH,C,CACD;;AACA,MAAMO,SAAS,GAAGV,YAAlB;AAEA,eAAeU,SAAf","sourcesContent":["import { whileMuted } from './utils.js';\nimport * as OriginalPropTypes$1 from 'prop-types';\n\nlet EnvPropTypes;\r\n// In the dev build of Recollect, we wrap PropTypes in a proxy so we can\r\n// mute the store while the prop types library reads the props.\r\n{\r\n    // The PropTypes object is made up of functions that call functions, so\r\n    // we recursively wrap responses in the same handler\r\n    const wrapMeIfYouCan = (item, handler) => {\r\n        if (typeof item === 'function' ||\r\n            (typeof item === 'object' && item !== null)) {\r\n            return new Proxy(item, handler);\r\n        }\r\n        return item;\r\n    };\r\n    const handler = {\r\n        get(...args) {\r\n            return wrapMeIfYouCan(Reflect.get(...args), this);\r\n        },\r\n        apply(...args) {\r\n            // Here we mute the function calls\r\n            const result = whileMuted(() => Reflect.apply(...args));\r\n            return wrapMeIfYouCan(result, this);\r\n        },\r\n    };\r\n    EnvPropTypes = new Proxy(OriginalPropTypes$1, handler);\r\n}\r\n// We do this so we're exporting a const (EnvPropTypes is a let)\r\nconst PropTypes = EnvPropTypes;\n\nexport default PropTypes;\n"]},"metadata":{},"sourceType":"module"}